//Promise------------------------------------------------------

//Promise (обещание) представляет собой объект, который используется для выполнения асинхронных операций и обработки их результатов (успешного или ошибочного). Обещания предоставляют более удобный и понятный способ работы с асинхронным кодом по сравнению с традиционными колбэками.

//Promise (обещание) часто считается лучше коллбэков (callback) по нескольким причинам:
//
// Улучшенная читаемость кода: Использование Promise делает код более читаемым и понятным, особенно при работе с асинхронными операциями. Это происходит потому, что Promise позволяет использовать цепочки вызовов с помощью .then() и .catch(), что делает поток выполнения более линейным и предсказуемым.
//
// Избежание "callback hell": При использовании коллбэков может возникнуть ситуация, когда вложенность коллбэков становится слишком глубокой, что делает код сложным для понимания и поддержки. Promise позволяет избежать этой проблемы, делая код более плоским и структурированным.
//
// Обработка ошибок: Promise предоставляет более удобный механизм для обработки ошибок с помощью метода .catch(). Это позволяет централизованно обрабатывать ошибки, что упрощает отладку и поддержку кода.
//
// Комбинирование и композиция: Promise позволяют легко комбинировать и составлять асинхронные операции с помощью методов Promise.all(), Promise.race() и других. Это делает код более гибким и мощным.
//
// Поддержка async/await: Promise являются основой для синтаксиса async/await, который позволяет писать асинхронный код в более синхронном стиле. Это делает код еще более читаемым и удобным для работы.

Пример использования Promise и коллбэков:
// Использование коллбэков
function fetchDataWithCallback(callback) {
    setTimeout(() => {
        callback(null, "Данные получены");
    }, 1000);
}

fetchDataWithCallback((err, data) => {
    if (err) {
        console.error(err);
    } else {
        console.log(data);
    }
});

// Использование Promise
function fetchDataWithPromise() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("Данные получены");
        }, 1000);
    });
}

fetchDataWithPromise()
    .then(data => {
        console.log(data);
    })
    .catch(err => {
        console.error(err);
    });

//Синтаксис создания Promise:
let promise = new Promise(function(resolve, reject) {
  // функция-исполнитель (executor)
  // "певец"
});

// Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат. В терминах нашей аналогии: исполнитель – это «певец».
// Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript. Наш код – только внутри исполнителя.

// Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
// resolve(value) — если работа завершилась успешно, с результатом value.
// reject(error) — если произошла ошибка, error – объект ошибки.

// Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать resolve или reject.
// У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
// state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
// result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).
// Так что исполнитель по итогу переводит promise в одно из двух состояний:

//Ниже пример конструктора Promise и простого исполнителя с кодом, дающим результат с задержкой (через setTimeout):

let promise = new Promise(function(resolve, reject) {
  // эта функция выполнится автоматически, при вызове new Promise

  // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
  setTimeout(() => resolve("done"), 1000);
});

// Мы можем наблюдать две вещи, запустив код выше:
// Функция-исполнитель запускается сразу же при вызове new Promise.
// Исполнитель получает два аргумента: resolve и reject — это функции, встроенные в JavaScript, поэтому нам не нужно их писать. Нам нужно лишь позаботиться, чтобы исполнитель вызвал одну из них по готовности.
// Спустя одну секунду «обработки» исполнитель вызовет resolve("done"), чтобы передать результат

//Это был пример успешно выполненной задачи, в результате мы получили «успешно выполненный» промис.
// А теперь пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:
let promise = new Promise(function(resolve, reject) {
  // спустя одну секунду будет сообщено, что задача выполнена с ошибкой
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});

//Подведём промежуточные итоги: исполнитель выполняет задачу (что-то, что обычно требует времени), затем вызывает resolve или reject, чтобы изменить состояние соответствующего Promise.
//
// Промис – и успешный, и отклонённый будем называть «завершённым», в отличие от изначального промиса «в ожидании».

//then, catch------------------------------------------------------

// Объект Promise служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов .then и .catch.

//then

//Синтаксис:
promise.then(
    function(result) { /* обработает успешное выполнение */ },
    function(error) { /* обработает ошибку */ }
);

//Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.
// Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

// Например, вот реакция на успешно выполненный промис:
let promise = new Promise(function(resolve, reject) {
    setTimeout(() => resolve("done!"), 1000);
});

// resolve запустит первую функцию, переданную в .then
promise.then(
    result => alert(result), // выведет "done!" через одну секунду
    error => alert(error) // не будет запущена
);

// Выполнилась первая функция.
//А в случае ошибки в промисе – выполнится вторая:
let promise = new Promise(function(resolve, reject) {
    setTimeout(() => reject(new Error("Whoops!")), 1000);
});
// reject запустит вторую функцию, переданную в .then
promise.then(
    result => alert(result), // не будет запущена
    error => alert(error) // выведет "Error: Whoops!" спустя одну секунду
);

//Если мы заинтересованы только в результате успешного выполнения задачи, то в then можно передать только одну функцию:
let promise = new Promise(resolve => {
    setTimeout(() => resolve("done!"), 1000);
});

promise.then(alert); // выведет "done!" спустя одну секунду

//catch

//Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает то же самое:

let promise = new Promise((resolve, reject) => {
    setTimeout(() => reject(new Error("Ошибка!")), 1000);
});
// .catch(f) это то же самое, что promise.then(null, f)
promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду

// Вызов .catch(f) – это сокращённый, «укороченный» вариант .then(null, f).

// Очистка: finally

//Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
// Идея finally состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций.
// Например, остановка индикаторов загрузки, закрытие больше не нужных соединений и т.д.

// Думайте об этом как о завершении вечеринки. Независимо от того, была ли вечеринка хорошей или плохой, сколько на ней было друзей, нам все равно нужно (или, по крайней мере, мы должны) сделать уборку после нее.

// Код может выглядеть следующим образом:
new Promise((resolve, reject) => {
  /* сделать что-то, что займёт время, и после вызвать resolve или может reject */
})
    // выполнится, когда промис завершится, независимо от того, успешно или нет
  .finally(() => остановить индикатор загрузки)
  // таким образом, индикатор загрузки всегда останавливается, прежде чем мы продолжим
  .then(result => показать результат, err => показать ошибку)

// Обратите внимание, что finally(f) – это не совсем псевдоним then(f,f), как можно было подумать.
// Есть важные различия:
// Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был завершён промис. И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.
// Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.

// Например, здесь результат проходит через finally к then:
new Promise((resolve, reject) => {
  setTimeout(() => resolve("value"), 2000);
})
  .finally(() => alert("Промис завершён")) // срабатывает первым
  .then(result => alert(result)); // <-- .then показывает "value"

// Как вы можете видеть, значение возвращаемое первым промисом, передается через finally к следующему then.
// Это очень удобно, потому что finally не предназначен для обработки результата промиса. Как уже было сказано, это место для проведения общей очистки, независимо от того, каков был результат.

// А здесь ошибка из промиса проходит через finally к catch:
new Promise((resolve, reject) => {
  throw new Error("error");
})
  .finally(() => alert("Промис завершён")) // срабатывает первым
  .catch(err => alert(err));  // <-- .catch показывает ошибку

// Подведем итог:
// Обработчик finally не получает результат предыдущего обработчика (у него нет аргументов). Вместо этого этот результат передается следующему подходящему обработчику.
// Если обработчик finally возвращает что-то, это игнорируется.
// Когда finally выдает ошибку, выполнение переходит к ближайшему обработчику ошибок.
// Эти функции полезны и заставляют все работать правильно, если мы используем finally так, как предполагается: для общих процедур очистки.

//Теперь рассмотрим пример того, как промисы могут облегчить нам написание асинхронного кода.
// У нас есть функция loadScript для загрузки скрипта

// Давайте вспомним, как выглядел вариант с колбэками:
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));

  document.head.append(script);
}

// Теперь перепишем её, используя Promise.
// Новой функции loadScript более не нужен аргумент callback. Вместо этого она будет создавать и возвращать объект Promise, который перейдет в состояние «успешно завершён», когда загрузка закончится. Внешний код может добавлять обработчики («подписчиков»), используя .then:

function loadScript(src) {
  return new Promise(function(resolve, reject) {
    let script = document.createElement('script');
    script.src = src;

    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`Ошибка загрузки скрипта ${src}`));

    document.head.append(script);
  });
}
// Применение:

let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");

promise.then(
  script => alert(`${script.src} загружен!`),
  error => alert(`Ошибка: ${error.message}`)
);

promise.then(script => alert('Ещё один обработчик...'));

// Сразу заметно несколько преимуществ перед подходом с использованием колбэков:

//Промисы:
// Промисы позволяют делать вещи в естественном порядке. Сперва мы запускаем loadScript(script), и затем (.then) мы пишем, что делать с результатом.
//Мы можем вызывать .then у Promise столько раз, сколько захотим. Каждый раз мы добавляем нового «фаната», новую функцию-подписчика в «список подписок». Больше об этом на следующем занятии

//Колбэки
//У нас должна быть функция callback на момент вызова loadScript(script, callback). Другими словами, нам нужно знать что делать с результатом до того, как вызовется loadScript.
//Колбэк может быть только один.

//Источник learn javascript: https://learn.javascript.ru/promise-basics